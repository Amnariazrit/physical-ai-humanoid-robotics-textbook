# ROS 2 Action Sequencing: Executing Planned Actions

In the previous chapter, we explored how Large Language Models (LLMs) can generate high-level plans—sequences of abstract actions—from natural language instructions. However, these plans need to be translated into concrete, executable commands for the robot. This is where ROS 2 Action Sequencing comes into play: it's the bridge between the cognitive planning layer (LLM) and the low-level robot control.

This chapter will focus on designing a ROS 2 system that can parse a sequence of actions generated by an LLM and execute them on a humanoid robot using ROS 2 Actions and other communication mechanisms. We'll discuss how to create a robust action sequencing framework that can handle execution, monitor progress, and report status.

## Architecture for Action Sequencing

Executing an LLM-generated plan typically involves a dedicated ROS 2 node or a set of nodes responsible for:

1.  **Plan Reception**: Receiving the sequence of high-level actions (e.g., a list of strings or a custom message type) from the LLM planning module.
2.  **Action Dispatcher**: Translating each abstract action into a specific ROS 2 Action Goal, Service Request, or Topic Message.
3.  **Execution Monitoring**: Sending the ROS 2 commands to the appropriate robot controllers (action servers, service servers, topic subscribers) and monitoring their execution status.
4.  **Feedback and Reporting**: Providing feedback to the LLM (or a human operator) about the progress and outcome of each action in the sequence.
5.  **Error Handling and Replanning**: Detecting execution failures and, if necessary, triggering the LLM to generate a revised plan.

### Key ROS 2 Components for Sequencing:

*   **ROS 2 Actions**: Ideal for executing individual high-level skills (e.g., `move_to_location`, `grasp_object`, `open_door`). Each action provides a goal, feedback, and result, which is crucial for monitoring plan progress.
*   **ROS 2 Services**: Can be used for instantaneous, blocking operations that are part of a sequence (e.g., `set_gripper_force`, `get_object_info`).
*   **ROS 2 Topics**: For continuous feedback from robot sensors or state updates.

## Designing Robot Skills (Actions)

For an LLM to generate an executable plan, the robot needs a well-defined "API" of skills. These skills should map to ROS 2 Actions or Services.

**Example Robot Skills as ROS 2 Actions**:

*   **`MoveToLocation.action`**:
    *   Goal: `string location_name` (e.g., "kitchen", "fridge")
    *   Result: `bool success`
    *   Feedback: `string current_location`, `float distance_remaining`
*   **`GraspObject.action`**:
    *   Goal: `string object_name` (e.g., "bottle", "cup")
    *   Result: `bool success`, `string grasped_object`
    *   Feedback: `string status_message`
*   **`OpenDoor.action`**:
    *   Goal: `string door_name` (e.g., "fridge_door")
    *   Result: `bool success`
    *   Feedback: `string status_message`

## Python Example: Executing a Simple LLM-Generated Plan

Let's assume an LLM has provided the following plan as a list of strings:

```
plan = [
    "move_to(fridge)",
    "open(fridge_door)",
    "grasp(bottle)",
    "close(fridge_door)",
    "move_to(table)"
]
```

We need a ROS 2 Python node to execute this.

### Conceptual Action Sequencing Node:

```python
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.callback_groups import ReentrantCallbackGroup
from rclpy.executors import MultiThreadedExecutor

# Import custom action messages (e.g., from a package like 'robot_skill_interfaces')
from robot_skill_interfaces.action import MoveToLocation, GraspObject, OpenDoor, CloseDoor

class ActionSequencer(Node):

    def __init__(self):
        super().__init__('action_sequencer')
        self.declare_parameter('llm_plan', [])
        self.llm_plan = []
        self.current_action_index = 0

        self.callback_group = ReentrantCallbackGroup()

        # Action Clients for each skill
        self._move_client = ActionClient(self, MoveToLocation, 'move_to_location', callback_group=self.callback_group)
        self._grasp_client = ActionClient(self, GraspObject, 'grasp_object', callback_group=self.callback_group)
        self._open_client = ActionClient(self, OpenDoor, 'open_door', callback_group=self.callback_group)
        self._close_client = ActionClient(self, CloseDoor, 'close_door', callback_group=self.callback_group)

        # Map action names to clients
        self.action_clients = {
            'move_to': self._move_client,
            'grasp': self._grasp_client,
            'open': self._open_client,
            'close': self._close_client,
        }

        self.get_logger().info("Action Sequencer Node initialized.")

        self.plan_executor_timer = self.create_timer(1.0, self.execute_next_action_in_plan)
        self.plan_executor_timer.cancel() # Start paused

    def start_plan_execution(self, plan_str_list):
        self.llm_plan = plan_str_list
        self.current_action_index = 0
        self.get_logger().info(f"Starting plan execution: {self.llm_plan}")
        self.plan_executor_timer.reset()

    def execute_next_action_in_plan(self):
        if self.current_action_index >= len(self.llm_plan):
            self.get_logger().info("Plan execution complete.")
            self.executing_action = False
            return

        action_str = self.llm_plan[self.current_action_index]
        self.get_logger().info(f"Executing action: {action_str}")
        self.executing_action = True

        # Parse action string (simplified for example)
        # Example: "move_to(fridge)" -> action_name="move_to", param="fridge"
        action_name_full = action_str.split('(')[0]
        params_str = action_str.split('(')[1].strip(')')

        action_name = action_name_full.split('_', 1)[0] # e.g., 'move', 'grasp'

        if action_name_full in self.action_clients: # Direct match for skill name
            client = self.action_clients[action_name_full]
            
            # Wait for action server
            if not client.wait_for_server(timeout_sec=5.0):
                self.get_logger().error(f"Action server for {action_name_full} not available. Aborting plan.")
                self.executing_action = False
                return

            goal_msg = None
            if action_name_full == 'move_to':
                goal_msg = MoveToLocation.Goal()
                goal_msg.location_name = params_str
            elif action_name_full == 'grasp':
                goal_msg = GraspObject.Goal()
                parts = params_str.split(',', 1) # Split object name and position
                goal_msg.object_name = parts[0].strip()
                if len(parts) > 1:
                    goal_msg.object_position = parts[1].strip() # Example: "x=0.5,y=0.1,z=0.0"
                else:
                    goal_msg.object_position = "" # No position given
            elif action_name_full == 'open':
                goal_msg = OpenDoor.Goal()
                goal_msg.door_name = params_str
            elif action_name_full == 'close':
                goal_msg = CloseDoor.Goal()
                goal_msg.door_name = params_str
            
            if goal_msg:
                self._send_goal_future = client.send_goal_async(goal_msg)
                self._send_goal_future.add_done_callback(self.goal_response_callback)
            else:
                self.get_logger().error(f"Failed to create goal message for action: {action_name_full}. Aborting.")
                self.executing_action = False
        else:
            self.get_logger().error(f"No action client found for skill: {action_name_full}. Aborting plan.")
            self.executing_action = False

    def goal_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().error(f'Goal rejected by server: {goal_handle.goal_id}')
            self.executing_action = False
            return

        self.get_logger().info(f'Goal accepted by server: {goal_handle.goal_id}')
        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def get_result_callback(self, future):
        result = future.result().result
        if result.success:
            self.get_logger().info(f"Action completed successfully.")
            self.current_action_index += 1
            # Wait a moment before next action for simulation realism
            time.sleep(0.5)
            self.execute_next_action() # Proceed to the next action in the plan
        else:
            self.get_logger().error(f"Action failed. Aborting plan.")
            self.executing_action = False


def main(args=None):
    rclpy.init(args=args)
    executor = MultiThreadedExecutor()
    action_sequencer_node = ActionSequencerNode()
    executor.add_node(action_sequencer_node)

    try:
        executor.spin()
    except KeyboardInterrupt:
        action_sequencer_node.get_logger().info("Action sequencer stopped.")
    finally:
        executor.shutdown()
        action_sequencer_node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()

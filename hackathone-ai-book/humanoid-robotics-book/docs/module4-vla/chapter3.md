# ROS 2 Action Sequencing: Executing Planned Actions

In the previous chapter, we explored how Large Language Models (LLMs) can generate high-level plans—sequences of abstract actions—from natural language instructions. However, these plans need to be translated into concrete, executable commands for the robot. This is where ROS 2 Action Sequencing comes into play: it's the bridge between the cognitive planning layer (LLM) and the low-level robot control.

This chapter will focus on designing a ROS 2 system that can parse a sequence of actions generated by an LLM and execute them on a humanoid robot using ROS 2 Actions and other communication mechanisms. We'll discuss how to create a robust action sequencing framework that can handle execution, monitor progress, and report status.

## Architecture for Action Sequencing

Executing an LLM-generated plan typically involves a dedicated ROS 2 node or a set of nodes responsible for:

1.  **Plan Reception**: Receiving the sequence of high-level actions (e.g., a list of strings or a custom message type) from the LLM planning module.
2.  **Action Dispatcher**: Translating each abstract action into a specific ROS 2 Action Goal, Service Request, or Topic Message.
3.  **Execution Monitoring**: Sending the ROS 2 commands to the appropriate robot controllers (action servers, service servers, topic subscribers) and monitoring their execution status.
4.  **Feedback and Reporting**: Providing feedback to the LLM (or a human operator) about the progress and outcome of each action in the sequence.
5.  **Error Handling and Replanning**: Detecting execution failures and, if necessary, triggering the LLM to generate a revised plan.

### Key ROS 2 Components for Sequencing:

*   **ROS 2 Actions**: Ideal for executing individual high-level skills (e.g., `move_to_location`, `grasp_object`, `open_door`). Each action provides a goal, feedback, and result, which is crucial for monitoring plan progress.
*   **ROS 2 Services**: Can be used for instantaneous, blocking operations that are part of a sequence (e.g., `set_gripper_force`, `get_object_info`).
*   **ROS 2 Topics**: For continuous feedback from robot sensors or state updates.

## Designing Robot Skills (Actions)

For an LLM to generate an executable plan, the robot needs a well-defined "API" of skills. These skills should map to ROS 2 Actions or Services.

**Example Robot Skills as ROS 2 Actions**:

*   **`MoveToLocation.action`**:
    *   Goal: `string location_name` (e.g., "kitchen", "fridge")
    *   Result: `bool success`
    *   Feedback: `string current_location`, `float distance_remaining`
*   **`GraspObject.action`**:
    *   Goal: `string object_name` (e.g., "bottle", "cup")
    *   Result: `bool success`, `string grasped_object`
    *   Feedback: `string status_message`
*   **`OpenDoor.action`**:
    *   Goal: `string door_name` (e.g., "fridge_door")
    *   Result: `bool success`
    *   Feedback: `string status_message`

## Python Example: Executing a Simple LLM-Generated Plan

Let's assume an LLM has provided the following plan as a list of strings:

```
plan = [
    "move_to(fridge)",
    "open(fridge_door)",
    "grasp(bottle)",
    "close(fridge_door)",
    "move_to(table)"
]
```

We need a ROS 2 Python node to execute this.

### Conceptual Action Sequencing Node:

```python
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.callback_groups import ReentrantCallbackGroup
from rclpy.executors import MultiThreadedExecutor

# Import custom action messages (e.g., from a package like 'robot_skill_interfaces')
from robot_skill_interfaces.action import MoveToLocation, GraspObject, OpenDoor, CloseDoor

class ActionSequencer(Node):

    def __init__(self):
        super().__init__('action_sequencer')
        self.declare_parameter('llm_plan', [])
        self.llm_plan = []
        self.current_action_index = 0

        self.callback_group = ReentrantCallbackGroup()

        # Action Clients for each skill
        self._move_client = ActionClient(self, MoveToLocation, 'move_to_location', callback_group=self.callback_group)
        self._grasp_client = ActionClient(self, GraspObject, 'grasp_object', callback_group=self.callback_group)
        self._open_client = ActionClient(self, OpenDoor, 'open_door', callback_group=self.callback_group)
        self._close_client = ActionClient(self, CloseDoor, 'close_door', callback_group=self.callback_group)

        # Map action names to clients
        self.action_clients = {
            'move_to': self._move_client,
            'grasp': self._grasp_client,
            'open': self._open_client,
            'close': self._close_client,
        }

        self.get_logger().info("Action Sequencer Node initialized.")

        self.plan_executor_timer = self.create_timer(1.0, self.execute_next_action_in_plan)
        self.plan_executor_timer.cancel() # Start paused

    def start_plan_execution(self, plan_str_list):
        self.llm_plan = plan_str_list
        self.current_action_index = 0
        self.get_logger().info(f"Starting plan execution: {self.llm_plan}")
        self.plan_executor_timer.reset()

    def execute_next_action_in_plan(self):
        if self.current_action_index >= len(self.llm_plan):
            self.get_logger().info("Plan execution complete.")
            self.plan_executor_timer.cancel()
            return

        action_str = self.llm_plan[self.current_action_index]
        self.get_logger().info(f"Executing action: {action_str}")

        # Parse action string (simplified for example)
        # Example: "move_to(fridge)" -> action_name="move_to", param="fridge"
        action_name = action_str.split('(')[0]
        param = action_str.split('(')[1].strip(')')

        if action_name in self.action_clients:
            client = self.action_clients[action_name]
            # Wait for action server
            if not client.wait_for_server(timeout_sec=5.0):
                self.get_logger().error(f"Action server for {action_name} not available. Aborting plan.")
                self.plan_executor_timer.cancel()
                return

            # Create goal message based on action type
            if action_name == 'move_to':
                goal_msg = MoveToLocation.Goal()
                goal_msg.location_name = param
            elif action_name == 'grasp':
                goal_msg = GraspObject.Goal()
                goal_msg.object_name = param
            elif action_name == 'open':
                goal_msg = OpenDoor.Goal()
                goal_msg.door_name = param
            elif action_name == 'close':
                goal_msg = CloseDoor.Goal()
                goal_msg.door_name = param
            else:
                self.get_logger().error(f"Unknown action type in plan: {action_name}. Aborting.")
                self.plan_executor_timer.cancel()
                return

            self._send_goal_future = client.send_goal_async(goal_msg)
            self._send_goal_future.add_done_callback(self.goal_response_callback)
        else:
            self.get_logger().error(f"No client found for action: {action_name}. Aborting plan.")
            self.plan_executor_timer.cancel()

    def goal_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().error(f'Goal rejected: {goal_handle.goal_id}')
            self.plan_executor_timer.cancel()
            return

        self.get_logger().info(f'Goal accepted: {goal_handle.goal_id}')
        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def get_result_callback(self, future):
        result = future.result().result
        if result.success:
            self.get_logger().info(f"Action completed successfully.")
            self.current_action_index += 1
            # Trigger next action immediately
            self.execute_next_action_in_plan()
        else:
            self.get_logger().error(f"Action failed. Aborting plan.")
            self.plan_executor_timer.cancel()


def main(args=None):
    rclpy.init(args=args)
    executor = MultiThreadedExecutor()
    action_sequencer = ActionSequencer()
    executor.add_node(action_sequencer)

    # Example LLM-generated plan (would come from another node)
    sample_plan = [
        "move_to(fridge)",
        "open(fridge_door)",
        "grasp(bottle)",
        "close(fridge_door)",
        "move_to(table)"
    ]
    action_sequencer.start_plan_execution(sample_plan)

    try:
        executor.spin()
    except KeyboardInterrupt:
        action_sequencer.get_logger().info("Action sequencer stopped.")
    finally:
        executor.shutdown()
        action_sequencer.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

### Challenges and Considerations:

*   **Robust Parsing**: The action string parsing needs to be robust to handle variations in LLM output.
*   **Action Definition**: Each robot skill (e.g., `MoveToLocation`) needs its own ROS 2 Action definition and a corresponding action server on the robot.
*   **Error Handling**: Comprehensive error handling is crucial, including what to do if an action fails or times out. This could involve replanning by the LLM.
*   **State Management**: The LLM often needs up-to-date information about the robot's state and environment to plan effectively.
*   **Safety**: Ensuring that the LLM-generated plans, when executed, do not lead to unsafe robot behaviors.

## Conclusion

ROS 2 Action Sequencing provides the necessary infrastructure to execute complex, multi-step plans generated by cognitive planning modules (like LLMs). By carefully defining robot skills as ROS 2 Actions and creating a robust action sequencer, we can enable humanoid robots to interpret and execute high-level human instructions, moving towards more autonomous and intelligent behavior. The next chapter will explore how to integrate multiple modalities—speech, gesture, and vision—to enrich human-robot interaction.

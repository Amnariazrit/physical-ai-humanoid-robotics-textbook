"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[1003],{4967:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>t,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"module1-ros2/chapter3","title":"ROS 2 Services and Actions: Synchronous and Asynchronous Calls","description":"In the previous chapter, we explored ROS 2 topics, which provide an asynchronous, one-way communication mechanism ideal for continuous data streams. This chapter introduces two other critical communication patterns: Services for synchronous request/reply interactions, and Actions for asynchronous, long-running tasks with feedback and preemption capabilities.","source":"@site/docs/module1-ros2/chapter3.md","sourceDirName":"module1-ros2","slug":"/module1-ros2/chapter3","permalink":"/physical-ai-humanoid-robotics-textbook/docs/module1-ros2/chapter3","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"ROS 2 Nodes and Topics: Communication in Robotics","permalink":"/physical-ai-humanoid-robotics-textbook/docs/module1-ros2/chapter2"},"next":{"title":"Python Integration: Bridging Python Agents to ROS 2","permalink":"/physical-ai-humanoid-robotics-textbook/docs/module1-ros2/chapter4"}}');var i=r(4848),c=r(8453);const t={},o="ROS 2 Services and Actions: Synchronous and Asynchronous Calls",a={},l=[{value:"Understanding ROS 2 Services",id:"understanding-ros-2-services",level:2},{value:"Key Characteristics of Services:",id:"key-characteristics-of-services",level:3},{value:"Python Example: Simple Service (Add Two Ints)",id:"python-example-simple-service-add-two-ints",level:3},{value:"Understanding ROS 2 Actions",id:"understanding-ros-2-actions",level:2},{value:"Key Characteristics of Actions:",id:"key-characteristics-of-actions",level:3},{value:"Python Example: Simple Action (Fibonacci)",id:"python-example-simple-action-fibonacci",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"ros-2-services-and-actions-synchronous-and-asynchronous-calls",children:"ROS 2 Services and Actions: Synchronous and Asynchronous Calls"})}),"\n",(0,i.jsxs)(n.p,{children:["In the previous chapter, we explored ROS 2 topics, which provide an asynchronous, one-way communication mechanism ideal for continuous data streams. This chapter introduces two other critical communication patterns: ",(0,i.jsx)(n.strong,{children:"Services"})," for synchronous request/reply interactions, and ",(0,i.jsx)(n.strong,{children:"Actions"})," for asynchronous, long-running tasks with feedback and preemption capabilities."]}),"\n",(0,i.jsx)(n.h2,{id:"understanding-ros-2-services",children:"Understanding ROS 2 Services"}),"\n",(0,i.jsxs)(n.p,{children:["ROS 2 Services enable nodes to perform synchronous, blocking communication. When a node needs a specific task to be executed and requires a direct response, it can act as a ",(0,i.jsx)(n.strong,{children:"client"})," and send a request to another node acting as a ",(0,i.jsx)(n.strong,{children:"server"}),". The server processes the request and sends back a single reply."]}),"\n",(0,i.jsx)(n.h3,{id:"key-characteristics-of-services",children:"Key Characteristics of Services:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Request/Reply Model"}),": A client sends a request, and a server sends a reply."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Synchronous"}),": The client typically waits (blocks) until it receives a reply from the server."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"One-time Interaction"}),": Suitable for tasks that can be completed in a single, well-defined interaction."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Service Definition"}),": Services are defined using ",(0,i.jsx)(n.code,{children:".srv"})," files, which specify the structure of the request and reply messages."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"python-example-simple-service-add-two-ints",children:"Python Example: Simple Service (Add Two Ints)"}),"\n",(0,i.jsx)(n.p,{children:"Let's create a simple service in Python where a server node adds two integers provided by a client node."}),"\n",(0,i.jsxs)(n.p,{children:["First, define the service type. In your ",(0,i.jsx)(n.code,{children:"py_pubsub"})," package (created in the previous chapter, assuming you've built it), create a ",(0,i.jsx)(n.code,{children:"srv"})," directory:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws/src/py_pubsub\r\nmkdir srv\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Inside the ",(0,i.jsx)(n.code,{children:"srv"})," directory, create a file named ",(0,i.jsx)(n.code,{children:"AddTwoInts.srv"})," with the following content:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"# Request\r\nint64 a\r\nint64 b\r\n---\r\n# Response\r\nint64 sum\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now, modify ",(0,i.jsx)(n.code,{children:"~/ros2_ws/src/py_pubsub/package.xml"})," to include the ",(0,i.jsx)(n.code,{children:"build_depend"})," and ",(0,i.jsx)(n.code,{children:"exec_depend"})," for ",(0,i.jsx)(n.code,{children:"rosidl_default_generators"})," and ",(0,i.jsx)(n.code,{children:"example_interfaces"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:"<build_depend>rclpy</build_depend>\r\n<build_depend>std_msgs</build_depend>\r\n<build_depend>rosidl_default_generators</build_depend> # Add this line\r\n<exec_depend>rclpy</exec_depend>\r\n<exec_depend>std_msgs</exec_depend>\r\n<exec_depend>rosidl_default_runtime</exec_depend> # Add this line\r\n<member_of_group>rosidl_interface_packages</member_of_group> # Add this line\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Also, modify ",(0,i.jsx)(n.code,{children:"~/ros2_ws/src/py_pubsub/setup.py"})," to ensure your service definition is processed:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from setuptools import find_packages, setup\r\nimport os\r\nfrom glob import glob\r\n\r\npackage_name = 'py_pubsub'\r\n\r\nsetup(\r\n    name=package_name,\r\n    version='0.0.0',\r\n    packages=find_packages(exclude=['test']),\r\n    data_files=[\r\n        ('share/' + package_name, ['package.xml']),\r\n        ('share/' + package_name + '/launch', ['launch/pubsub_launch.py']),\r\n        (os.path.join('share', package_name, 'srv'), glob('srv/*.srv')), # Add this line\r\n    ],\r\n    install_requires=['setuptools'],\r\n    zip_safe=True,\r\n    maintainer='your_name',\r\n    maintainer_email='your_email@example.com',\r\n    description='ROS 2 Python publisher and subscriber example',\r\n    license='Apache-2.0',\r\n    tests_require=['pytest'],\r\n    entry_points={\r\n        'console_scripts': [\r\n            'talker = py_pubsub.publisher_member_function:main',\r\n            'listener = py_pubsub.subscriber_member_function:main',\r\n            'add_two_ints_server = py_pubsub.service_member_function:main', # Add this line\r\n            'add_two_ints_client = py_pubsub.client_member_function:main', # Add this line\r\n        ],\r\n    },\r\n)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now create the server (",(0,i.jsx)(n.code,{children:"service_member_function.py"}),") and client (",(0,i.jsx)(n.code,{children:"client_member_function.py"}),") files inside ",(0,i.jsx)(n.code,{children:"~/ros2_ws/src/py_pubsub/py_pubsub/"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"service_member_function.py"})," (Server):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\n\r\nfrom py_pubsub.srv import AddTwoInts # Import your custom service type\r\n\r\n\r\nclass MinimalService(Node):\r\n\r\n    def __init__(self):\r\n        super().__init__('minimal_service')\r\n        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)\r\n\r\n    def add_two_ints_callback(self, request, response):\r\n        response.sum = request.a + request.b\r\n        self.get_logger().info('Incoming request\\na: %d b: %d' % (request.a, request.b))\r\n        return response\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n\r\n    minimal_service = MinimalService()\r\n\r\n    rclpy.spin(minimal_service)\r\n\r\n    rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"client_member_function.py"})," (Client):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import sys\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\n\r\nfrom py_pubsub.srv import AddTwoInts # Import your custom service type\r\n\r\n\r\nclass MinimalClientAsync(Node):\r\n\r\n    def __init__(self):\r\n        super().__init__('minimal_client_async')\r\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\r\n        while not self.cli.wait_for_service(timeout_sec=1.0):\r\n            self.get_logger().info('service not available, waiting again...')\r\n        self.req = AddTwoInts.Request()\r\n\r\n    def send_request(self, a, b):\r\n        self.req.a = a\r\n        self.req.b = b\r\n        self.future = self.cli.call_async(self.req)\r\n        rclpy.spin_until_future_complete(self, self.future)\r\n        return self.future.result()\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n\r\n    minimal_client = MinimalClientAsync()\r\n    response = minimal_client.send_request(int(sys.argv[1]), int(sys.argv[2]))\r\n    minimal_client.get_logger().info(\r\n        'Result of add_two_ints: for %d + %d = %d' %\r\n        (minimal_client.req.a, minimal_client.req.b, response.sum))\r\n\r\n    minimal_client.destroy_node()\r\n    rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,i.jsx)(n.p,{children:"Build and Run:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws/\r\ncolcon build --packages-select py_pubsub\r\n. install/setup.bash # Source your workspace\n"})}),"\n",(0,i.jsx)(n.p,{children:"Open two terminals. In the first, start the server:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ros2 run py_pubsub add_two_ints_server\n"})}),"\n",(0,i.jsx)(n.p,{children:"In the second, start the client, providing two integers as arguments:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ros2 run py_pubsub add_two_ints_client 2 3\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The server should log the incoming request, and the client should log the result ",(0,i.jsx)(n.code,{children:"5"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"understanding-ros-2-actions",children:"Understanding ROS 2 Actions"}),"\n",(0,i.jsx)(n.p,{children:'ROS 2 Actions extend the concept of services for long-running, asynchronous operations that may provide periodic feedback and can be preempted (cancelled). They are ideal for tasks like "move robot to a goal position" or "pick up an object," where the execution takes time and you might want to monitor progress or stop the action midway.'}),"\n",(0,i.jsx)(n.h3,{id:"key-characteristics-of-actions",children:"Key Characteristics of Actions:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Goal/Feedback/Result Model"}),":\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Goal"}),": The request sent by the client to initiate the action."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Feedback"}),": Periodic updates from the server about the progress of the action."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Result"}),": The final outcome of the action (success, failure, aborted)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Asynchronous"}),": The client doesn't block while waiting for the action to complete."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Preemption"}),": A client can request to cancel an active goal on the server."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Action Definition"}),": Actions are defined using ",(0,i.jsx)(n.code,{children:".action"})," files, specifying the structure of the goal, feedback, and result messages."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"python-example-simple-action-fibonacci",children:"Python Example: Simple Action (Fibonacci)"}),"\n",(0,i.jsx)(n.p,{children:"Let's create a simple action in Python where an action server computes a Fibonacci sequence up to a given order, and an action client requests this computation."}),"\n",(0,i.jsxs)(n.p,{children:["Define the action type. In your ",(0,i.jsx)(n.code,{children:"py_pubsub"})," package ",(0,i.jsx)(n.code,{children:"srv"})," directory, create an ",(0,i.jsx)(n.code,{children:"action"})," directory. Change ",(0,i.jsx)(n.code,{children:"py_pubsub"})," to ",(0,i.jsx)(n.code,{children:"action_tutorials_interfaces"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws/src\r\nros2 pkg create --build-type ament_python action_tutorials_interfaces\r\ncd action_tutorials_interfaces\r\nmkdir action\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Inside ",(0,i.jsx)(n.code,{children:"action_tutorials_interfaces/action"}),", create ",(0,i.jsx)(n.code,{children:"Fibonacci.action"})," with the content:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"# Goal\r\nint32 order\r\n---\r\n# Result\r\nint32[] sequence\r\n---\r\n# Feedback\r\nint32[] sequence\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Modify ",(0,i.jsx)(n.code,{children:"~/ros2_ws/src/action_tutorials_interfaces/package.xml"})," and ",(0,i.jsx)(n.code,{children:"~/ros2_ws/src/action_tutorials_interfaces/setup.py"})," similar to how you did for services, but for actions."]}),"\n",(0,i.jsxs)(n.p,{children:["Now create the server (",(0,i.jsx)(n.code,{children:"fibonacci_action_server.py"}),") and client (",(0,i.jsx)(n.code,{children:"fibonacci_action_client.py"}),") files inside ",(0,i.jsx)(n.code,{children:"~/ros2_ws/src/py_pubsub/py_pubsub/"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"fibonacci_action_server.py"})," (Server):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import time\r\n\r\nimport rclpy\r\nfrom rclpy.action import ActionServer\r\nfrom rclpy.node import Node\r\n\r\nfrom action_tutorials_interfaces.action import Fibonacci # Correct import path\r\n\r\n\r\nclass FibonacciActionServer(Node):\r\n\r\n    def __init__(self):\r\n        super().__init__('fibonacci_action_server')\r\n        self._action_server = ActionServer(\r\n            self,\r\n            Fibonacci,\r\n            'fibonacci',\r\n            self.execute_callback)\r\n\r\n    def execute_callback(self, goal_handle):\r\n        self.get_logger().info('Executing goal...')\r\n\r\n        sequence = [0, 1]\r\n        for i in range(1, goal_handle.request.order):\r\n            if goal_handle.is_cancel_requested:\r\n                goal_handle.canceled()\r\n                self.get_logger().info('Goal canceled')\r\n                return Fibonacci.Result()\r\n\r\n            sequence.append(sequence[i] + sequence[i-1])\r\n            feedback_msg = Fibonacci.Feedback()\r\n            feedback_msg.sequence = sequence\r\n            goal_handle.publish_feedback(feedback_msg)\r\n            self.get_logger().info('Feedback: {0}'.format(feedback_msg.sequence))\r\n            time.sleep(1)\r\n\r\n        goal_handle.succeed()\r\n\r\n        result = Fibonacci.Result()\r\n        result.sequence = sequence\r\n        self.get_logger().info('Result: {0}'.format(result.sequence))\r\n        return result\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n\r\n    fibonacci_action_server = FibonacciActionServer()\r\n\r\n    rclpy.spin(fibonacci_action_server)\r\n\r\n    fibonacci_action_server.destroy_node()\r\n    rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"fibonacci_action_client.py"})," (Client):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.action import ActionClient\r\nfrom rclpy.node import Node\r\n\r\nfrom action_tutorials_interfaces.action import Fibonacci # Correct import path\r\n\r\n\r\nclass FibonacciActionClient(Node):\r\n\r\n    def __init__(self):\r\n        super().__init__('fibonacci_action_client')\r\n        self._action_client = ActionClient(self, Fibonacci, 'fibonacci')\r\n\r\n    def send_goal(self, order):\r\n        goal_msg = Fibonacci.Goal()\r\n        goal_msg.order = order\r\n\r\n        self._action_client.wait_for_server()\r\n\r\n        self._send_goal_future = self._action_client.send_goal_async(goal_msg, feedback_callback=self.feedback_callback)\r\n\r\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\r\n\r\n    def goal_response_callback(self, future):\r\n        goal_handle = future.result()\r\n        if not goal_handle.accepted:\r\n            self.get_logger().info('Goal rejected :(')\r\n            return\r\n\r\n        self.get_logger().info('Goal accepted :)')\r\n\r\n        self._get_result_future = goal_handle.get_result_async()\r\n        self._get_result_future.add_done_callback(self.get_result_callback)\r\n\r\n    def get_result_callback(self, future):\r\n        result = future.result().result\r\n        self.get_logger().info('Result: {0}'.format(result.sequence))\r\n        rclpy.shutdown()\r\n\r\n    def feedback_callback(self, feedback_msg):\r\n        self.get_logger().info('Received feedback: {0}'.format(feedback_msg.feedback.sequence))\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n\r\n    action_client = FibonacciActionClient()\r\n    action_client.send_goal(10)\r\n\r\n    rclpy.spin(action_client)\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,i.jsx)(n.p,{children:"Build and Run:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws/\r\ncolcon build --packages-select py_pubsub action_tutorials_interfaces\r\n. install/setup.bash # Source your workspace\n"})}),"\n",(0,i.jsx)(n.p,{children:"Open two terminals. In the first, start the action server:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ros2 run py_pubsub fibonacci_action_server\n"})}),"\n",(0,i.jsx)(n.p,{children:"In the second, start the action client:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ros2 run py_pubsub fibonacci_action_client\n"})}),"\n",(0,i.jsx)(n.p,{children:"You should see the server executing the Fibonacci sequence, sending feedback to the client, and finally a result."}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"Services and Actions provide powerful mechanisms for synchronous request/reply and asynchronous long-running task management in ROS 2. By combining them with topics, you can build sophisticated and robust robotic applications that effectively manage various communication needs. The next chapter will explore Python integration in more detail."})]})}function u(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>o});var s=r(6540);const i={},c=s.createContext(i);function t(e){const n=s.useContext(c);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),s.createElement(c.Provider,{value:n},e.children)}}}]);
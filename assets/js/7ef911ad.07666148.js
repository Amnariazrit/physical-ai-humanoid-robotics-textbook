"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[1493],{972:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"module1-ros2/chapter5","title":"URDF for Humanoids: Robot Description and Simulation Basics","description":"The Unified Robot Description Format (URDF) is an XML format used in ROS to describe the physical characteristics of a robot. It allows you to define the robot\'s kinematics (links and joints), visual properties (geometry and colors), and collision properties (shapes for physics simulation). For humanoid robots, URDF is crucial for accurately representing their complex structure, enabling simulation, visualization, and motion planning.","source":"@site/docs/module1-ros2/chapter5.md","sourceDirName":"module1-ros2","slug":"/module1-ros2/chapter5","permalink":"/physical-ai-humanoid-robotics-textbook/docs/module1-ros2/chapter5","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module1-ros2/chapter5.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Python Integration: Bridging Python Agents to ROS 2","permalink":"/physical-ai-humanoid-robotics-textbook/docs/module1-ros2/chapter4"},"next":{"title":"Gazebo Basics: Environment Setup and Physics Simulation","permalink":"/physical-ai-humanoid-robotics-textbook/docs/module2-gazebo/chapter1"}}');var o=i(4848),s=i(8453);const t={},a="URDF for Humanoids: Robot Description and Simulation Basics",l={},d=[{value:"Understanding URDF Structure",id:"understanding-urdf-structure",level:2},{value:"Key Elements within URDF",id:"key-elements-within-urdf",level:3},{value:"Xacro: Simplifying URDF",id:"xacro-simplifying-urdf",level:2},{value:"Generic Humanoid URDF Model",id:"generic-humanoid-urdf-model",level:2},{value:"Example: <code>generic_humanoid.urdf.xacro</code>",id:"example-generic_humanoidurdfxacro",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"urdf-for-humanoids-robot-description-and-simulation-basics",children:"URDF for Humanoids: Robot Description and Simulation Basics"})}),"\n",(0,o.jsx)(n.p,{children:"The Unified Robot Description Format (URDF) is an XML format used in ROS to describe the physical characteristics of a robot. It allows you to define the robot's kinematics (links and joints), visual properties (geometry and colors), and collision properties (shapes for physics simulation). For humanoid robots, URDF is crucial for accurately representing their complex structure, enabling simulation, visualization, and motion planning."}),"\n",(0,o.jsx)(n.p,{children:"This chapter will introduce the fundamentals of URDF, focusing on its application to humanoid robots. We will cover how to define links, joints, and transmissions, and how to use these descriptions for visualization in tools like RViz and for basic simulation in Gazebo."}),"\n",(0,o.jsx)(n.h2,{id:"understanding-urdf-structure",children:"Understanding URDF Structure"}),"\n",(0,o.jsxs)(n.p,{children:["A URDF file is an XML document with a ",(0,o.jsx)(n.code,{children:"<robot>"})," root element. Inside, it defines two primary elements:"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"<link>"})}),": Represents a rigid body segment of the robot (e.g., torso, upper arm, thigh). Links have physical properties like mass, inertia, and visual/collision geometry."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"<joint>"})}),": Describes the connection between two links. Joints define the degrees of freedom (DOF) and the kinematic relationship between parent and child links."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"key-elements-within-urdf",children:"Key Elements within URDF"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsxs)(n.strong,{children:[(0,o.jsx)(n.code,{children:"<link>"})," Elements"]}),":\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"<visual>"})}),": Defines the graphical representation of the link (e.g., mesh file, primitive shape like a box or cylinder) and its color. This is what you see in RViz."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"<collision>"})}),": Defines the geometry used for collision detection in physics simulations. It's often a simplified version of the visual geometry."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"<inertial>"})}),": Specifies the link's mass, center of mass (origin), and inertia matrix. Essential for accurate physics simulation."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsxs)(n.strong,{children:[(0,o.jsx)(n.code,{children:"<joint>"})," Elements"]}),":\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"name"})}),": Unique identifier for the joint."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"type"})}),": Defines the type of joint (e.g., ",(0,o.jsx)(n.code,{children:"revolute"}),", ",(0,o.jsx)(n.code,{children:"prismatic"}),", ",(0,o.jsx)(n.code,{children:"fixed"}),", ",(0,o.jsx)(n.code,{children:"continuous"}),"). Humanoids typically use ",(0,o.jsx)(n.code,{children:"revolute"})," for rotating joints (like elbows, knees) and ",(0,o.jsx)(n.code,{children:"fixed"})," for rigid connections."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsxs)(n.strong,{children:[(0,o.jsx)(n.code,{children:"<parent>"})," and ",(0,o.jsx)(n.code,{children:"<child>"})]}),": Specify the ",(0,o.jsx)(n.code,{children:"link"})," elements that the joint connects."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"<origin>"})}),": Defines the transform from the parent link's origin to the joint's origin."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"<axis>"})}),": For revolute/prismatic joints, specifies the axis of rotation/translation."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"<limit>"})}),": For revolute/prismatic joints, defines the upper and lower limits of the joint's movement, and its velocity/effort limits."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"<dynamics>"})}),": Defines friction and damping properties."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"<mimic>"})}),": Allows one joint to mimic the motion of another joint."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsxs)(n.strong,{children:[(0,o.jsx)(n.code,{children:"<transmission>"})," (Xacro/URDF Extension)"]}),":\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["While not strictly part of core URDF, ",(0,o.jsx)(n.code,{children:"transmission"})," elements are often used with URDFs, especially for hardware interfacing. They describe the relationship between actuators and joints, crucial for ",(0,o.jsx)(n.code,{children:"ros2_control"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"xacro-simplifying-urdf",children:"Xacro: Simplifying URDF"}),"\n",(0,o.jsx)(n.p,{children:"Writing complex URDF files manually can be tedious and prone to errors, especially for humanoids with many links and joints. Xacro (XML Macros) is an XML macro language that allows you to use macros, properties, and arithmetic operations within your URDF, making it more modular, readable, and easier to maintain."}),"\n",(0,o.jsxs)(n.p,{children:["You convert a ",(0,o.jsx)(n.code,{children:".xacro"})," file to a ",(0,o.jsx)(n.code,{children:".urdf"})," file using the ",(0,o.jsx)(n.code,{children:"xacro"})," command-line tool."]}),"\n",(0,o.jsx)(n.h2,{id:"generic-humanoid-urdf-model",children:"Generic Humanoid URDF Model"}),"\n",(0,o.jsx)(n.p,{children:"Below is a simplified example of a generic humanoid URDF structure. This example focuses on the basic kinematic chain for a torso, head, and single arm, demonstrating links and revolute joints. A full humanoid would extend this significantly for legs, a second arm, hands, and feet."}),"\n",(0,o.jsxs)(n.h3,{id:"example-generic_humanoidurdfxacro",children:["Example: ",(0,o.jsx)(n.code,{children:"generic_humanoid.urdf.xacro"})]}),"\n",(0,o.jsx)(n.p,{children:"To keep the example concise and modular, we will use Xacro."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<robot name="generic_humanoid" xmlns:xacro="http://www.ros.org/wiki/xacro">\r\n\r\n  \x3c!-- Define common properties/macros --\x3e\r\n  <xacro:property name="M_PI" value="3.1415926535897931" />\r\n  <xacro:property name="body_mass" value="1.0" />\r\n  <xacro:property name="body_len" value="0.2" />\r\n  <xacro:property name="body_rad" value="0.05" />\r\n\r\n  \x3c!-- Macro for a generic cylinder link with inertia --\x3e\r\n  <xacro:macro name="cylinder_link" params="name mass length radius">\r\n    <link name="${name}">\r\n      <visual>\r\n        <geometry>\r\n          <cylinder length="${length}" radius="${radius}"/>\r\n        </geometry>\r\n        <material name="blue">\r\n          <color rgba="0 0 0.8 1"/>\r\n        </material>\r\n      </visual>\r\n      <collision>\r\n        <geometry>\r\n          <cylinder length="${length}" radius="${radius}"/>\r\n        </geometry>\r\n      </collision>\r\n      <inertial>\r\n        <mass value="${mass}"/>\r\n        <inertia ixx="${(1/12)*mass*(3*radius*radius + length*length)}" ixy="0.0" ixz="0.0"\r\n                 iyy="${(1/12)*mass*(3*radius*radius + length*length)}" iyz="0.0"\r\n                 izz="${(1/2)*mass*radius*radius}"/>\r\n      </inertial>\r\n    </link>\r\n  </xacro:macro>\r\n\r\n  \x3c!-- Base Link: Torso --\x3e\r\n  <xacro:cylinder_link name="torso_link" mass="${body_mass}" length="${body_len}" radius="${body_rad}"/>\r\n\r\n  \x3c!-- Head Joint and Link --\x3e\r\n  <joint name="head_joint" type="revolute">\r\n    <parent link="torso_link"/>\r\n    <child link="head_link"/>\r\n    <origin xyz="0 0 ${body_len/2 + body_len/4}" rpy="0 0 0"/>\r\n    <axis xyz="0 0 1"/>\r\n    <limit lower="${-M_PI/4}" upper="${M_PI/4}" effort="10.0" velocity="1.0"/>\r\n  </joint>\r\n  <xacro:cylinder_link name="head_link" mass="${body_mass/4}" length="${body_len/2}" radius="${body_rad/2}"/>\r\n\r\n  \x3c!-- Right Shoulder Joint and Link --\x3e\r\n  <joint name="right_shoulder_joint" type="revolute">\r\n    <parent link="torso_link"/>\r\n    <child link="right_upper_arm_link"/>\r\n    <origin xyz="0 ${-(body_rad + body_len/4)} 0" rpy="0 0 0"/>\r\n    <axis xyz="1 0 0"/>\r\n    <limit lower="${-M_PI/2}" upper="${M_PI/2}" effort="10.0" velocity="1.0"/>\r\n  </joint>\r\n  <xacro:cylinder_link name="right_upper_arm_link" mass="${body_mass/4}" length="${body_len}" radius="${body_rad/3}"/>\r\n\r\n  \x3c!-- Right Elbow Joint and Link --\x3e\r\n  <joint name="right_elbow_joint" type="revolute">\r\n    <parent link="right_upper_arm_link"/>\r\n    <child link="right_forearm_link"/>\r\n    <origin xyz="0 0 ${-body_len/2}" rpy="0 0 0"/>\r\n    <axis xyz="1 0 0"/>\r\n    <limit lower="${-M_PI/2}" upper="${0}" effort="10.0" velocity="1.0"/>\r\n  </joint>\r\n  <xacro:cylinder_link name="right_forearm_link" mass="${body_mass/6}" length="${body_len}" radius="${body_rad/4}"/>\r\n\r\n</robot>\n'})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>a});var r=i(6540);const o={},s=r.createContext(o);function t(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);